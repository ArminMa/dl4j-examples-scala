package org.deeplearning4j.examples.tictactoe

import java.io.File

import org.datavec.api.util.ClassPathResource
import org.nd4j.linalg.api.ndarray.INDArray
import org.nd4j.linalg.factory.Nd4j

/**
  * <b>Developed by KIT Solutions Pvt. Ltd.</b> (www.kitsol.com) on 24-Aug-16.
  * This program is used for training.(Update the move reward based on the win or loose of the game).
  * Here both player are being played automatically and update probability in AllMoveWithReward.txt.
  * AllMoveWithReward.txt file can be any file containing TicTacToe data generated by running TicTacToeData.java or any other old file
  * updated by this program when run earlier.
  */
object TicTacToeGameTrainer {

  def main(args: Array[String]) {

    // selects file contains TicTacToe data generated by running TicTacToeData.java
    var filePath = ""
    try {
      filePath = new ClassPathResource("tictactoe").getFile.getAbsolutePath + File.separator + "AllMoveWithReward.txt"
    } catch {
      case e: Exception =>
        println("FilePathException" + e.toString)
    }

    // This is the object of TicTacToePlayer class which contains all methods to make move and find best move and update probability
    // of each move based on winning or losing or drawing the game.
    val player = new TicTacToePlayer

    // need to set file path containing basic game data which will be updated during training.
    player.setFilePath(filePath)

    // thread to start loading of a file asynchronously.
    val aiLoad = new Thread(player)
    aiLoad.start()

    // need to set number of games after which you want to write data file with latest data.
    player.setUpdateLimit(1000)

    // This property is set to tell TicTacToePlayer to update probability in data file.
    // data file is not updated if you set this as false.
    // This property is false by default
    player.setAutoUpdate(true)

    // counter to monitor number of games played as training proceeds.
    var totalGameCounter = 0

    // number of games that player 1 won
    var numberOfWinPlayer1 = 0

    // number of games that player 2 won
    var numberOfWinPlayer2 = 0

    // number of games to play during training.
    val playTotalGame = 10000
    // number of games played as draw games.
    var draw = 0

    // to control whether a move was of a first player or a second player to request a next board positions from TicTacToePlayer object.
    var tempMoveType = 0

    // This is a variable to do the training for all 9 empty positions when training starts.
    var movePosition = 0

    // sets a player number for first player
    // it can be 1 or 2, i.e. X or O.
    val firstPlayerNumber = 1 //1-For First Player and 2- for second Player
    if (firstPlayerNumber == 1) {
      tempMoveType = 2
    } else if (firstPlayerNumber == 2) {
      tempMoveType = 1
    }

    // Following logic uses TicTacToePlayer object to play each game and use it to update probability for
    // each won/loose or draw game.
    var board: INDArray = null

    // if played games becomes greater than total number of games to play then exits the loop
    while (totalGameCounter < playTotalGame) {
      try {
        Thread.sleep(10)
        var moveType: Int = tempMoveType
        // checks whether data file is fully loaded or not before moving further in training.

        if (player.isAILoad) {

          // create blank board.
          board = Nd4j.zeros(1, 9)
          // board.putScalar(new int[]{0,4}, firstPlayerNumber);

          // puts X or O (1 or 2 respectively) depending on the first player number.
          board.putScalar(Array[Int](0, movePosition), firstPlayerNumber)

          // increases movePosition by 1 to play upto 9 positions of the board
          movePosition += 1

          // if movePosition becomes greater than 8, then set it to 0 to restart from first position again.
          if (movePosition > 8) {
            movePosition = 0
          }

          // increase total games played counter by 1.
          totalGameCounter += 1

          // print board to console for logging purpose.
          // we can comment this line if not required.
          printBoard(board)



          board = player.getNextBestMove(board, moveType)
          printBoard(board)
          var gameState = player.getGameDecision

          // if gameState != 0, means game is finished with a decision
          // below while loop plays actual game automatically.
          while (gameState == 0) {
              // setting moveType to particular player to request next game board
              if (moveType == 1) {
                moveType = 2
              } else {
                moveType = 1
              }

              // gets next best board move by passing current board state.
              board = player.getNextBestMove(board, moveType)

              // prints board.
              printBoard(board)

              // verifies current game decision (win or draw)
              gameState = player.getGameDecision
            }

            if (gameState == 1) { // player 1 won
              numberOfWinPlayer1 += 1
            } else if (gameState == 2) { // player 2 won
              numberOfWinPlayer2 += 1
            } else { // game is draw
              draw += 1
            }

            println("Total Game :" + String.valueOf(totalGameCounter))
            println("   X Player:" + String.valueOf(numberOfWinPlayer1))
            println("   O Player:" + String.valueOf(numberOfWinPlayer2))
            println("   XXDrawOO:" + String.valueOf(draw))

          }
        } catch { case e: Exception =>
          println(e.toString)
        }
    }
  }

  /**
    * Prints the board on a console as given below
    * 0 0 1
    * 2 0 0
    * 0 0 1
    */
  def printBoard(board: INDArray) {
    var k: Int = 0
    for (i <- 0 until 3) {
      for (j <- 0 until 3) {
        val position: Int = board.getDouble(k).toInt
        print("  " + position)
        k += 1
      }
      println("")
    }
    println("------------")
  }
}
