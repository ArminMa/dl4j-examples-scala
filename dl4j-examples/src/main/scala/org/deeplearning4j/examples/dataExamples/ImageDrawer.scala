package org.deeplearning4j.examples.dataExamples

import org.deeplearning4j.nn.api.OptimizationAlgorithm
import org.deeplearning4j.nn.conf.{NeuralNetConfiguration, Updater}
import org.deeplearning4j.nn.conf.layers.{DenseLayer, OutputLayer}
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork
import org.deeplearning4j.nn.weights.WeightInit
import org.nd4j.linalg.activations.Activation
import org.nd4j.linalg.api.ndarray.INDArray
import org.nd4j.linalg.dataset.DataSet
import org.nd4j.linalg.factory.Nd4j
import org.nd4j.linalg.lossfunctions.LossFunctions

import javafx.application.{Application, Platform}
import javafx.scene.Scene
import javafx.scene.image._
import javafx.scene.layout.HBox
import javafx.scene.paint.Color
import javafx.stage.Stage

/**
  * JavaFX application to show a neural network learning to draw an image.
  * Demonstrates how to feed an NN with externally originated data.
  *
  * This example uses JavaFX, which requires the Oracle JDK. Comment out this example if you use a different JDK.
  * OpenJDK and openjfx have been reported to work fine.
  *
  * TODO: sample does not shut down correctly. Process must be stopped from the IDE.
  *
  * @author Robert Altena
  */
object ImageDrawer {

  def main(args: Array[String]): Unit = {
    Application.launch(classOf[ImageDrawer], args: _*)
  }

  /**
    * Build the Neural network.
    */
  private def createNN: MultiLayerNetwork = {
    val seed = 2345
    val iterations = 25 //<-- Just the one iteration per call to fit.
    val learningRate = 0.1
    val numInputs = 2 // x and y.
    val numHiddenNodes = 25
    val numOutputs = 3 //R, G and B value.
    val conf = new NeuralNetConfiguration.Builder()
      .seed(seed)
      .iterations(iterations)
      .optimizationAlgo(OptimizationAlgorithm.STOCHASTIC_GRADIENT_DESCENT)
      .learningRate(learningRate)
      .weightInit(WeightInit.XAVIER)
      .updater(Updater.NESTEROVS)
      .momentum(0.9)
      .list
      .layer(0, new DenseLayer.Builder().nIn(numInputs).nOut(numHiddenNodes)
        .activation(Activation.IDENTITY)
        .build)
      .layer(1, new DenseLayer.Builder().nIn(numHiddenNodes).nOut(numHiddenNodes)
        .activation(Activation.RELU)
        .build)
      .layer(2, new DenseLayer.Builder().nIn(numHiddenNodes).nOut(numHiddenNodes)
        .activation(Activation.RELU)
        .build)
      .layer(3, new DenseLayer.Builder().nIn(numHiddenNodes).nOut(numHiddenNodes)
        .activation(Activation.RELU)
        .build)
      .layer(4, new OutputLayer.Builder(LossFunctions.LossFunction.L2)
        .activation(Activation.IDENTITY).nIn(numHiddenNodes).nOut(numOutputs)
        .build)
      .pretrain(false).backprop(true)
      .build
    val net = new MultiLayerNetwork(conf)
    net.init()

    net
  }

  /**
    * Process a javafx Image to be consumed by DeepLearning4J
    *
    * @param img Javafx image to process
    * @return DeepLearning4J DataSet.
    */
  private def generateDataSet(img: Image): DataSet = {
    val w = img.getWidth.toInt
    val h = img.getHeight.toInt
    val numPoints = h * w
    val reader = img.getPixelReader
    val xy = Nd4j.zeros(numPoints, 2)
    val out = Nd4j.zeros(numPoints, 3)

    //Simplest implementation first.
    for (i <- 0 until w) {
      val xp = i.toDouble / (w - 1).toDouble
      for (j <- 0 until h) {
        val c = reader.getColor(i, j)
        val index = i + w * j
        val yp = j.toDouble / (h - 1).toDouble

        xy.put(index, 0, xp) //2 inputs. x and y.
        xy.put(index, 1, yp)

        out.put(index, 0, c.getRed) //3 outputs. the RGB values.
        out.put(index, 1, c.getGreen)
        out.put(index, 2, c.getBlue)
      }
    }
    new DataSet(xy, out)
  }

  /**
    * Make sure the color values are >=0 and <=1
    */
  private def capNNOutput(x: Double): Double = {
    val tmp = if (x < 0.0) 0.0 else x
    if (tmp > 1.0) 1.0 else tmp
  }

}

class ImageDrawer extends Application {

  private var originalImage: Image = null //The source image displayed on the left.
  private var composition: WritableImage = null // Destination image generated by the NN.
  private var nn: MultiLayerNetwork = null // THE nn.
  private var ds: DataSet = null //Training data generated (only once) from the Original, used to train.
  private var xyOut: INDArray = null //x,y grid to calculate the output image. Needs to be calculated once, then re-used.

  /**
    * Training the NN and updating the current graphical output.
    */
  private val onCalc = new Runnable {
    def run(): Unit = {
      nn.fit(ds)
      drawImage()
    }
  }

  override def init() {
    originalImage = new Image("/DataExamples/Mona_Lisa.png")

    val w = originalImage.getWidth.toInt
    val h = originalImage.getHeight.toInt
    composition = new WritableImage(w, h) //Right image.

    ds = ImageDrawer.generateDataSet(originalImage)
    nn = ImageDrawer.createNN

    // The x,y grid to calculate the NN output only needs to be calculated once.
    val numPoints = h * w
    xyOut = Nd4j.zeros(numPoints, 2)
    for (i <- 0 until w) {
      val xp = i.toDouble / (w - 1).toDouble
      for (j <- 0 until h) {
        val index = i + w * j
        val yp = j.toDouble / (h - 1).toDouble
        xyOut.put(index, 0, xp)
        xyOut.put(index, 1, yp)
      }
    }
    drawImage()
  }

  /**
    * Standard JavaFX start: Build the UI, display
    */
  def start(primaryStage: Stage) {

    val w = originalImage.getWidth.toInt
    val h = originalImage.getHeight.toInt
    val zoom = 5 // Our images are a tad small, display them enlarged to have something to look at.

    val iv1 = new ImageView //Left image
    iv1.setImage(originalImage)
    iv1.setFitHeight(zoom * h)
    iv1.setFitWidth(zoom * w)

    val iv2 = new ImageView
    iv2.setImage(composition)
    iv2.setFitHeight(zoom * h)
    iv2.setFitWidth(zoom * w)

    val root = new HBox //build the scene.
    val scene = new Scene(root)
    root.getChildren.addAll(iv1, iv2)

    primaryStage.setTitle("Neural Network Drawing Demo.")
    primaryStage.setScene(scene)
    primaryStage.show()

    Platform.setImplicitExit(true)

    //Allow JavaFX do to it's thing, Initialize the Neural network when it feels like it.
    Platform.runLater(this.onCalc)
  }

  /**
    * Make the Neural network draw the image.
    */
  private def drawImage() {
    val w = composition.getWidth.toInt
    val h = composition.getHeight.toInt
    val out = nn.output(xyOut)
    val writer = composition.getPixelWriter
    for (i <- 0 until w) {
      for (j <- 0 until h) {
        val index = i + w * j
        val red = ImageDrawer.capNNOutput(out.getDouble(index, 0))
        val green = ImageDrawer.capNNOutput(out.getDouble(index, 1))
        val blue = ImageDrawer.capNNOutput(out.getDouble(index, 2))

        val c = new Color(red, green, blue, 1.0)
        writer.setColor(i, j, c)
      }
    }
  }

}
